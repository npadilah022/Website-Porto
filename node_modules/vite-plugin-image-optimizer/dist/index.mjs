import x from "fs";
import B from "fs/promises";
function R(e = "") {
  return !e || !e.includes("\\") ? e : e.replace(/\\/g, "/");
}
const M = /^[/\\]{2}/, C = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/, D = /^[A-Za-z]:$/, q = "/", T = function(e) {
  if (e.length === 0)
    return ".";
  e = R(e);
  const n = e.match(M), i = S(e), l = e[e.length - 1] === "/";
  return e = N(e, !i), e.length === 0 ? i ? "/" : l ? "./" : "." : (l && (e += "/"), D.test(e) && (e += "/"), n ? i ? `//${e}` : `//./${e}` : i && !S(e) ? `/${e}` : e);
}, z = function(...e) {
  if (e.length === 0)
    return ".";
  let n;
  for (const i of e)
    i && i.length > 0 && (n === void 0 ? n = i : n += `/${i}`);
  return n === void 0 ? "." : T(n.replace(/\/\/+/g, "/"));
};
function N(e, n) {
  let i = "", l = 0, t = -1, r = 0, s = null;
  for (let o = 0; o <= e.length; ++o) {
    if (o < e.length)
      s = e[o];
    else {
      if (s === "/")
        break;
      s = "/";
    }
    if (s === "/") {
      if (!(t === o - 1 || r === 1))
        if (r === 2) {
          if (i.length < 2 || l !== 2 || i[i.length - 1] !== "." || i[i.length - 2] !== ".") {
            if (i.length > 2) {
              const g = i.lastIndexOf("/");
              g === -1 ? (i = "", l = 0) : (i = i.slice(0, g), l = i.length - 1 - i.lastIndexOf("/")), t = o, r = 0;
              continue;
            } else if (i.length > 0) {
              i = "", l = 0, t = o, r = 0;
              continue;
            }
          }
          n && (i += i.length > 0 ? "/.." : "..", l = 2);
        } else
          i.length > 0 ? i += `/${e.slice(t + 1, o)}` : i = e.slice(t + 1, o), l = o - t - 1;
      t = o, r = 0;
    } else
      s === "." && r !== -1 ? ++r : r = -1;
  }
  return i;
}
const S = function(e) {
  return C.test(e);
}, W = /.(\.[^./]+)$/, E = function(e) {
  const n = W.exec(R(e));
  return n && n[1] || "";
}, P = function(e, n) {
  const i = R(e).split("/").pop();
  return n && i.endsWith(n) ? i.slice(0, -n.length) : i;
}, G = /(^|[/\\])([^/\\]+?)(?=(\.[^.]+)?$)/;
function v(e) {
  var n;
  return (n = e.match(G)) == null ? void 0 : n[2];
}
var h = {}, V = {
  get exports() {
    return h;
  },
  set exports(e) {
    h = e;
  }
}, k = {}, U = {
  get exports() {
    return k;
  },
  set exports(e) {
    k = e;
  }
}, $;
function X() {
  return $ || ($ = 1, function(e) {
    const n = typeof process < "u" && process.env.TERM_PROGRAM === "Hyper", i = typeof process < "u" && process.platform === "win32", l = typeof process < "u" && process.platform === "linux", t = {
      ballotDisabled: "☒",
      ballotOff: "☐",
      ballotOn: "☑",
      bullet: "•",
      bulletWhite: "◦",
      fullBlock: "█",
      heart: "❤",
      identicalTo: "≡",
      line: "─",
      mark: "※",
      middot: "·",
      minus: "－",
      multiplication: "×",
      obelus: "÷",
      pencilDownRight: "✎",
      pencilRight: "✏",
      pencilUpRight: "✐",
      percent: "%",
      pilcrow2: "❡",
      pilcrow: "¶",
      plusMinus: "±",
      question: "?",
      section: "§",
      starsOff: "☆",
      starsOn: "★",
      upDownArrow: "↕"
    }, r = Object.assign({}, t, {
      check: "√",
      cross: "×",
      ellipsisLarge: "...",
      ellipsis: "...",
      info: "i",
      questionSmall: "?",
      pointer: ">",
      pointerSmall: "»",
      radioOff: "( )",
      radioOn: "(*)",
      warning: "‼"
    }), s = Object.assign({}, t, {
      ballotCross: "✘",
      check: "✔",
      cross: "✖",
      ellipsisLarge: "⋯",
      ellipsis: "…",
      info: "ℹ",
      questionFull: "？",
      questionSmall: "﹖",
      pointer: l ? "▸" : "❯",
      pointerSmall: l ? "‣" : "›",
      radioOff: "◯",
      radioOn: "◉",
      warning: "⚠"
    });
    e.exports = i && !n ? r : s, Reflect.defineProperty(e.exports, "common", { enumerable: !1, value: t }), Reflect.defineProperty(e.exports, "windows", { enumerable: !1, value: r }), Reflect.defineProperty(e.exports, "other", { enumerable: !1, value: s });
  }(U)), k;
}
const Z = (e) => e !== null && typeof e == "object" && !Array.isArray(e), H = /[\u001b\u009b][[\]#;?()]*(?:(?:(?:[^\W_]*;?[^\W_]*)\u0007)|(?:(?:[0-9]{1,4}(;[0-9]{0,4})*)?[~0-9=<>cf-nqrtyA-PRZ]))/g, K = () => typeof process < "u" ? process.env.FORCE_COLOR !== "0" : !1, F = () => {
  const e = {
    enabled: K(),
    visible: !0,
    styles: {},
    keys: {}
  }, n = (r) => {
    let s = r.open = `\x1B[${r.codes[0]}m`, o = r.close = `\x1B[${r.codes[1]}m`, g = r.regex = new RegExp(`\\u001b\\[${r.codes[1]}m`, "g");
    return r.wrap = (a, c) => {
      a.includes(o) && (a = a.replace(g, o + s));
      let u = s + a + o;
      return c ? u.replace(/\r*\n/g, `${o}$&${s}`) : u;
    }, r;
  }, i = (r, s, o) => typeof r == "function" ? r(s) : r.wrap(s, o), l = (r, s) => {
    if (r === "" || r == null)
      return "";
    if (e.enabled === !1)
      return r;
    if (e.visible === !1)
      return "";
    let o = "" + r, g = o.includes(`
`), a = s.length;
    for (a > 0 && s.includes("unstyle") && (s = [.../* @__PURE__ */ new Set(["unstyle", ...s])].reverse()); a-- > 0; )
      o = i(e.styles[s[a]], o, g);
    return o;
  }, t = (r, s, o) => {
    e.styles[r] = n({ name: r, codes: s }), (e.keys[o] || (e.keys[o] = [])).push(r), Reflect.defineProperty(e, r, {
      configurable: !0,
      enumerable: !0,
      set(a) {
        e.alias(r, a);
      },
      get() {
        let a = (c) => l(c, a.stack);
        return Reflect.setPrototypeOf(a, e), a.stack = this.stack ? this.stack.concat(r) : [r], a;
      }
    });
  };
  return t("reset", [0, 0], "modifier"), t("bold", [1, 22], "modifier"), t("dim", [2, 22], "modifier"), t("italic", [3, 23], "modifier"), t("underline", [4, 24], "modifier"), t("inverse", [7, 27], "modifier"), t("hidden", [8, 28], "modifier"), t("strikethrough", [9, 29], "modifier"), t("black", [30, 39], "color"), t("red", [31, 39], "color"), t("green", [32, 39], "color"), t("yellow", [33, 39], "color"), t("blue", [34, 39], "color"), t("magenta", [35, 39], "color"), t("cyan", [36, 39], "color"), t("white", [37, 39], "color"), t("gray", [90, 39], "color"), t("grey", [90, 39], "color"), t("bgBlack", [40, 49], "bg"), t("bgRed", [41, 49], "bg"), t("bgGreen", [42, 49], "bg"), t("bgYellow", [43, 49], "bg"), t("bgBlue", [44, 49], "bg"), t("bgMagenta", [45, 49], "bg"), t("bgCyan", [46, 49], "bg"), t("bgWhite", [47, 49], "bg"), t("blackBright", [90, 39], "bright"), t("redBright", [91, 39], "bright"), t("greenBright", [92, 39], "bright"), t("yellowBright", [93, 39], "bright"), t("blueBright", [94, 39], "bright"), t("magentaBright", [95, 39], "bright"), t("cyanBright", [96, 39], "bright"), t("whiteBright", [97, 39], "bright"), t("bgBlackBright", [100, 49], "bgBright"), t("bgRedBright", [101, 49], "bgBright"), t("bgGreenBright", [102, 49], "bgBright"), t("bgYellowBright", [103, 49], "bgBright"), t("bgBlueBright", [104, 49], "bgBright"), t("bgMagentaBright", [105, 49], "bgBright"), t("bgCyanBright", [106, 49], "bgBright"), t("bgWhiteBright", [107, 49], "bgBright"), e.ansiRegex = H, e.hasColor = e.hasAnsi = (r) => (e.ansiRegex.lastIndex = 0, typeof r == "string" && r !== "" && e.ansiRegex.test(r)), e.alias = (r, s) => {
    let o = typeof s == "string" ? e[s] : s;
    if (typeof o != "function")
      throw new TypeError("Expected alias to be the name of an existing color (string) or a function");
    o.stack || (Reflect.defineProperty(o, "name", { value: r }), e.styles[r] = o, o.stack = [r]), Reflect.defineProperty(e, r, {
      configurable: !0,
      enumerable: !0,
      set(g) {
        e.alias(r, g);
      },
      get() {
        let g = (a) => l(a, g.stack);
        return Reflect.setPrototypeOf(g, e), g.stack = this.stack ? this.stack.concat(o.stack) : o.stack, g;
      }
    });
  }, e.theme = (r) => {
    if (!Z(r))
      throw new TypeError("Expected theme to be an object");
    for (let s of Object.keys(r))
      e.alias(s, r[s]);
    return e;
  }, e.alias("unstyle", (r) => typeof r == "string" && r !== "" ? (e.ansiRegex.lastIndex = 0, r.replace(e.ansiRegex, "")) : ""), e.alias("noop", (r) => r), e.none = e.clear = e.noop, e.stripColor = e.unstyle, e.symbols = X(), e.define = t, e;
};
V.exports = F();
h.create = F;
function _(e) {
  if (typeof e != "object" || e === null)
    return e;
  const n = Array.isArray(e) ? [] : {};
  for (const i in e) {
    const l = e[i];
    n[i] = _(l);
  }
  return n;
}
function Y(e, n) {
  const i = _(e);
  for (const l in n)
    i[l] === void 0 && (i[l] = n[l]);
  return i;
}
function j(e) {
  let n = [];
  try {
    x.existsSync(e) && (x.lstatSync(e).isDirectory() ? x.readdirSync(e).forEach(function(t) {
      const r = j(z(e, "/", t));
      n = n.concat(r);
    }) : n.push(e));
  } catch {
  }
  return n;
}
const J = "vite-plugin-image-optimizer", Q = {
  logStats: !0,
  includePublic: !0,
  exclude: void 0,
  include: void 0,
  test: /\.(jpe?g|png|gif|tiff|webp|svg|avif)$/i,
  svg: {
    multipass: !0,
    plugins: [
      {
        name: "preset-default",
        params: {
          overrides: {
            cleanupNumericValues: !1,
            removeViewBox: !1
          },
          cleanupIDs: {
            minify: !1,
            remove: !1
          },
          convertPathData: !1
        }
      },
      "sortAttrs",
      {
        name: "addAttributesToSVGElement",
        params: {
          attributes: [{ xmlns: "http://www.w3.org/2000/svg" }]
        }
      }
    ]
  },
  png: {
    quality: 100
  },
  jpeg: {
    quality: 100
  },
  jpg: {
    quality: 100
  },
  tiff: {
    quality: 100
  },
  gif: {},
  webp: {
    lossless: !0
  },
  avif: {
    lossless: !0
  }
};
function ne(e = {}) {
  const n = Y(e, Q);
  let i, l, t;
  const r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), o = async (c, u) => {
    const f = require("svgo").optimize;
    return Buffer.from(
      f(u, {
        path: c,
        ...n.svg
      }).data
    );
  }, g = async (c, u) => {
    const f = require("sharp"), p = E(c).replace(".", "");
    return await f(u, { animated: p === "gif" }).toFormat(p, n[p.toLowerCase()]).toBuffer();
  }, a = async (c, u) => {
    try {
      const p = await (/\.svg$/.test(c) ? o : g)(c, u), b = p.byteLength, d = u.byteLength, y = b >= d;
      return r.set(c, {
        size: b / 1024,
        oldSize: d / 1024,
        ratio: Math.floor(100 * (b / d - 1)),
        skipWrite: y
      }), { content: p, skipWrite: y };
    } catch {
      return i.logger.error(`'${c}' - failed optimization`), {};
    }
  };
  return {
    name: J,
    enforce: "post",
    apply: "build",
    configResolved(c) {
      i = c, l = c.build.outDir, typeof c.publicDir == "string" && (t = c.publicDir);
    },
    generateBundle: async (c, u) => {
      const f = [], p = Object.keys(u);
      if (n.include ? p.forEach((b) => {
        const d = u[b].name;
        O(d, n.include) && f.push(b);
      }) : p.forEach((b) => {
        if (n.test.test(b)) {
          const d = u[b].name;
          A(d, n.exclude) || f.push(b);
        }
      }), f.length > 0) {
        const b = f.map(async (d) => {
          const y = u[d].source, { content: m, skipWrite: w } = await a(d, y);
          (m == null ? void 0 : m.length) > 0 && !w && (u[d].source = m);
        });
        await Promise.all(b).catch((d) => i.logger.error(d));
      }
    },
    async closeBundle() {
      if (t && n.includePublic) {
        const c = [], u = j(t);
        if (n.include ? u.forEach((f) => {
          const p = v(f) + E(f);
          O(p, n.include) && c.push(f);
        }) : u.forEach((f) => {
          if (n.test.test(f)) {
            const p = v(f) + E(f);
            A(p, n.exclude) || c.push(f);
          }
        }), c.length > 0) {
          const f = c.map(async (p) => {
            const b = p.replace(t + q, ""), d = z(l, b);
            if (x.existsSync(d) === !1)
              return;
            const { mtimeMs: y } = await B.stat(d);
            if (y <= (s.get(b) || 0))
              return;
            const m = await B.readFile(d), { content: w, skipWrite: I } = await a(b, m);
            (w == null ? void 0 : w.length) > 0 && !I && (await B.writeFile(d, w), s.set(b, Date.now()));
          });
          await Promise.all(f).catch((p) => i.logger.error(p));
        }
      }
      n.logStats && ee(i, r);
    }
  };
}
function O(e, n) {
  return L(e, n);
}
function A(e, n) {
  return L(e, n);
}
function L(e, n) {
  const i = Object.prototype.toString.call(n) === "[object String]", l = Object.prototype.toString.call(n) === "[object RegExp]", t = Array.isArray(n);
  return i ? e === n : l ? n.test(e) : t ? n.includes(e) : !1;
}
function ee(e, n) {
  e.logger.info(
    `
✨ ${h.cyan("[vite-plugin-image-optimizer]")} - optimized image resources successfully: `
  );
  const i = Array.from(n.keys(), (s) => s.length), l = Array.from(n.values(), (s) => `${Math.floor(100 * s.ratio)}`.length), t = Math.max(...i), r = Math.max(...l);
  n.forEach((s, o) => {
    const { size: g, oldSize: a, ratio: c, skipWrite: u } = s, f = c > 0 ? h.red(`+${c}%`) : c <= 0 ? h.green(`${c}%`) : "", p = u ? `${h.yellow.bold("skipped")} ${h.dim(
      `original: ${a.toFixed(2)}kb <= optimized: ${g.toFixed(2)}kb`
    )}` : h.dim(`${a.toFixed(2)}kb -> ${g.toFixed(2)}kb`);
    e.logger.info(
      h.dim(P(e.build.outDir)) + "/" + h.blueBright(o) + " ".repeat(2 + t - o.length) + h.gray(`${f} ${" ".repeat(r - `${c}`.length)}`) + " " + p
    );
  }), e.logger.info(`
`);
}
export {
  ne as ViteImageOptimizer
};
