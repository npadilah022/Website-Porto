<<<<<<< HEAD
"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const x=require("fs"),B=require("fs/promises");function R(e=""){return!e||!e.includes("\\")?e:e.replace(/\\/g,"/")}const M=/^[/\\]{2}/,q=/^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/,C=/^[A-Za-z]:$/,D="/",T=function(e){if(e.length===0)return".";e=R(e);const n=e.match(M),i=S(e),l=e[e.length-1]==="/";return e=N(e,!i),e.length===0?i?"/":l?"./":".":(l&&(e+="/"),C.test(e)&&(e+="/"),n?i?`//${e}`:`//./${e}`:i&&!S(e)?`/${e}`:e)},z=function(...e){if(e.length===0)return".";let n;for(const i of e)i&&i.length>0&&(n===void 0?n=i:n+=`/${i}`);return n===void 0?".":T(n.replace(/\/\/+/g,"/"))};function N(e,n){let i="",l=0,t=-1,r=0,s=null;for(let o=0;o<=e.length;++o){if(o<e.length)s=e[o];else{if(s==="/")break;s="/"}if(s==="/"){if(!(t===o-1||r===1))if(r===2){if(i.length<2||l!==2||i[i.length-1]!=="."||i[i.length-2]!=="."){if(i.length>2){const g=i.lastIndexOf("/");g===-1?(i="",l=0):(i=i.slice(0,g),l=i.length-1-i.lastIndexOf("/")),t=o,r=0;continue}else if(i.length>0){i="",l=0,t=o,r=0;continue}}n&&(i+=i.length>0?"/..":"..",l=2)}else i.length>0?i+=`/${e.slice(t+1,o)}`:i=e.slice(t+1,o),l=o-t-1;t=o,r=0}else s==="."&&r!==-1?++r:r=-1}return i}const S=function(e){return q.test(e)},W=/.(\.[^./]+)$/,E=function(e){const n=W.exec(R(e));return n&&n[1]||""},P=function(e,n){const i=R(e).split("/").pop();return n&&i.endsWith(n)?i.slice(0,-n.length):i},G=/(^|[/\\])([^/\\]+?)(?=(\.[^.]+)?$)/;function v(e){var n;return(n=e.match(G))==null?void 0:n[2]}var h={},V={get exports(){return h},set exports(e){h=e}},k={},U={get exports(){return k},set exports(e){k=e}},O;function X(){return O||(O=1,function(e){const n=typeof process<"u"&&process.env.TERM_PROGRAM==="Hyper",i=typeof process<"u"&&process.platform==="win32",l=typeof process<"u"&&process.platform==="linux",t={ballotDisabled:"☒",ballotOff:"☐",ballotOn:"☑",bullet:"•",bulletWhite:"◦",fullBlock:"█",heart:"❤",identicalTo:"≡",line:"─",mark:"※",middot:"·",minus:"－",multiplication:"×",obelus:"÷",pencilDownRight:"✎",pencilRight:"✏",pencilUpRight:"✐",percent:"%",pilcrow2:"❡",pilcrow:"¶",plusMinus:"±",question:"?",section:"§",starsOff:"☆",starsOn:"★",upDownArrow:"↕"},r=Object.assign({},t,{check:"√",cross:"×",ellipsisLarge:"...",ellipsis:"...",info:"i",questionSmall:"?",pointer:">",pointerSmall:"»",radioOff:"( )",radioOn:"(*)",warning:"‼"}),s=Object.assign({},t,{ballotCross:"✘",check:"✔",cross:"✖",ellipsisLarge:"⋯",ellipsis:"…",info:"ℹ",questionFull:"？",questionSmall:"﹖",pointer:l?"▸":"❯",pointerSmall:l?"‣":"›",radioOff:"◯",radioOn:"◉",warning:"⚠"});e.exports=i&&!n?r:s,Reflect.defineProperty(e.exports,"common",{enumerable:!1,value:t}),Reflect.defineProperty(e.exports,"windows",{enumerable:!1,value:r}),Reflect.defineProperty(e.exports,"other",{enumerable:!1,value:s})}(U)),k}const Z=e=>e!==null&&typeof e=="object"&&!Array.isArray(e),H=/[\u001b\u009b][[\]#;?()]*(?:(?:(?:[^\W_]*;?[^\W_]*)\u0007)|(?:(?:[0-9]{1,4}(;[0-9]{0,4})*)?[~0-9=<>cf-nqrtyA-PRZ]))/g,K=()=>typeof process<"u"?process.env.FORCE_COLOR!=="0":!1,F=()=>{const e={enabled:K(),visible:!0,styles:{},keys:{}},n=r=>{let s=r.open=`\x1B[${r.codes[0]}m`,o=r.close=`\x1B[${r.codes[1]}m`,g=r.regex=new RegExp(`\\u001b\\[${r.codes[1]}m`,"g");return r.wrap=(a,c)=>{a.includes(o)&&(a=a.replace(g,o+s));let f=s+a+o;return c?f.replace(/\r*\n/g,`${o}$&${s}`):f},r},i=(r,s,o)=>typeof r=="function"?r(s):r.wrap(s,o),l=(r,s)=>{if(r===""||r==null)return"";if(e.enabled===!1)return r;if(e.visible===!1)return"";let o=""+r,g=o.includes(`
`),a=s.length;for(a>0&&s.includes("unstyle")&&(s=[...new Set(["unstyle",...s])].reverse());a-- >0;)o=i(e.styles[s[a]],o,g);return o},t=(r,s,o)=>{e.styles[r]=n({name:r,codes:s}),(e.keys[o]||(e.keys[o]=[])).push(r),Reflect.defineProperty(e,r,{configurable:!0,enumerable:!0,set(a){e.alias(r,a)},get(){let a=c=>l(c,a.stack);return Reflect.setPrototypeOf(a,e),a.stack=this.stack?this.stack.concat(r):[r],a}})};return t("reset",[0,0],"modifier"),t("bold",[1,22],"modifier"),t("dim",[2,22],"modifier"),t("italic",[3,23],"modifier"),t("underline",[4,24],"modifier"),t("inverse",[7,27],"modifier"),t("hidden",[8,28],"modifier"),t("strikethrough",[9,29],"modifier"),t("black",[30,39],"color"),t("red",[31,39],"color"),t("green",[32,39],"color"),t("yellow",[33,39],"color"),t("blue",[34,39],"color"),t("magenta",[35,39],"color"),t("cyan",[36,39],"color"),t("white",[37,39],"color"),t("gray",[90,39],"color"),t("grey",[90,39],"color"),t("bgBlack",[40,49],"bg"),t("bgRed",[41,49],"bg"),t("bgGreen",[42,49],"bg"),t("bgYellow",[43,49],"bg"),t("bgBlue",[44,49],"bg"),t("bgMagenta",[45,49],"bg"),t("bgCyan",[46,49],"bg"),t("bgWhite",[47,49],"bg"),t("blackBright",[90,39],"bright"),t("redBright",[91,39],"bright"),t("greenBright",[92,39],"bright"),t("yellowBright",[93,39],"bright"),t("blueBright",[94,39],"bright"),t("magentaBright",[95,39],"bright"),t("cyanBright",[96,39],"bright"),t("whiteBright",[97,39],"bright"),t("bgBlackBright",[100,49],"bgBright"),t("bgRedBright",[101,49],"bgBright"),t("bgGreenBright",[102,49],"bgBright"),t("bgYellowBright",[103,49],"bgBright"),t("bgBlueBright",[104,49],"bgBright"),t("bgMagentaBright",[105,49],"bgBright"),t("bgCyanBright",[106,49],"bgBright"),t("bgWhiteBright",[107,49],"bgBright"),e.ansiRegex=H,e.hasColor=e.hasAnsi=r=>(e.ansiRegex.lastIndex=0,typeof r=="string"&&r!==""&&e.ansiRegex.test(r)),e.alias=(r,s)=>{let o=typeof s=="string"?e[s]:s;if(typeof o!="function")throw new TypeError("Expected alias to be the name of an existing color (string) or a function");o.stack||(Reflect.defineProperty(o,"name",{value:r}),e.styles[r]=o,o.stack=[r]),Reflect.defineProperty(e,r,{configurable:!0,enumerable:!0,set(g){e.alias(r,g)},get(){let g=a=>l(a,g.stack);return Reflect.setPrototypeOf(g,e),g.stack=this.stack?this.stack.concat(o.stack):o.stack,g}})},e.theme=r=>{if(!Z(r))throw new TypeError("Expected theme to be an object");for(let s of Object.keys(r))e.alias(s,r[s]);return e},e.alias("unstyle",r=>typeof r=="string"&&r!==""?(e.ansiRegex.lastIndex=0,r.replace(e.ansiRegex,"")):""),e.alias("noop",r=>r),e.none=e.clear=e.noop,e.stripColor=e.unstyle,e.symbols=X(),e.define=t,e};V.exports=F();h.create=F;function _(e){if(typeof e!="object"||e===null)return e;const n=Array.isArray(e)?[]:{};for(const i in e){const l=e[i];n[i]=_(l)}return n}function Y(e,n){const i=_(e);for(const l in n)i[l]===void 0&&(i[l]=n[l]);return i}function j(e){let n=[];try{x.existsSync(e)&&(x.lstatSync(e).isDirectory()?x.readdirSync(e).forEach(function(t){const r=j(z(e,"/",t));n=n.concat(r)}):n.push(e))}catch{}return n}const J="vite-plugin-image-optimizer",Q={logStats:!0,includePublic:!0,exclude:void 0,include:void 0,test:/\.(jpe?g|png|gif|tiff|webp|svg|avif)$/i,svg:{multipass:!0,plugins:[{name:"preset-default",params:{overrides:{cleanupNumericValues:!1,removeViewBox:!1},cleanupIDs:{minify:!1,remove:!1},convertPathData:!1}},"sortAttrs",{name:"addAttributesToSVGElement",params:{attributes:[{xmlns:"http://www.w3.org/2000/svg"}]}}]},png:{quality:100},jpeg:{quality:100},jpg:{quality:100},tiff:{quality:100},gif:{},webp:{lossless:!0},avif:{lossless:!0}};function ee(e={}){const n=Y(e,Q);let i,l,t;const r=new Map,s=new Map,o=async(c,f)=>{const u=require("svgo").optimize;return Buffer.from(u(f,{path:c,...n.svg}).data)},g=async(c,f)=>{const u=require("sharp"),p=E(c).replace(".","");return await u(f,{animated:p==="gif"}).toFormat(p,n[p.toLowerCase()]).toBuffer()},a=async(c,f)=>{try{const p=await(/\.svg$/.test(c)?o:g)(c,f),b=p.byteLength,d=f.byteLength,y=b>=d;return r.set(c,{size:b/1024,oldSize:d/1024,ratio:Math.floor(100*(b/d-1)),skipWrite:y}),{content:p,skipWrite:y}}catch{return i.logger.error(`'${c}' - failed optimization`),{}}};return{name:J,enforce:"post",apply:"build",configResolved(c){i=c,l=c.build.outDir,typeof c.publicDir=="string"&&(t=c.publicDir)},generateBundle:async(c,f)=>{const u=[],p=Object.keys(f);if(n.include?p.forEach(b=>{const d=f[b].name;$(d,n.include)&&u.push(b)}):p.forEach(b=>{if(n.test.test(b)){const d=f[b].name;A(d,n.exclude)||u.push(b)}}),u.length>0){const b=u.map(async d=>{const y=f[d].source,{content:m,skipWrite:w}=await a(d,y);(m==null?void 0:m.length)>0&&!w&&(f[d].source=m)});await Promise.all(b).catch(d=>i.logger.error(d))}},async closeBundle(){if(t&&n.includePublic){const c=[],f=j(t);if(n.include?f.forEach(u=>{const p=v(u)+E(u);$(p,n.include)&&c.push(u)}):f.forEach(u=>{if(n.test.test(u)){const p=v(u)+E(u);A(p,n.exclude)||c.push(u)}}),c.length>0){const u=c.map(async p=>{const b=p.replace(t+D,""),d=z(l,b);if(x.existsSync(d)===!1)return;const{mtimeMs:y}=await B.stat(d);if(y<=(s.get(b)||0))return;const m=await B.readFile(d),{content:w,skipWrite:I}=await a(b,m);(w==null?void 0:w.length)>0&&!I&&(await B.writeFile(d,w),s.set(b,Date.now()))});await Promise.all(u).catch(p=>i.logger.error(p))}}n.logStats&&te(i,r)}}}function $(e,n){return L(e,n)}function A(e,n){return L(e,n)}function L(e,n){const i=Object.prototype.toString.call(n)==="[object String]",l=Object.prototype.toString.call(n)==="[object RegExp]",t=Array.isArray(n);return i?e===n:l?n.test(e):t?n.includes(e):!1}function te(e,n){e.logger.info(`
✨ ${h.cyan("[vite-plugin-image-optimizer]")} - optimized image resources successfully: `);const i=Array.from(n.keys(),s=>s.length),l=Array.from(n.values(),s=>`${Math.floor(100*s.ratio)}`.length),t=Math.max(...i),r=Math.max(...l);n.forEach((s,o)=>{const{size:g,oldSize:a,ratio:c,skipWrite:f}=s,u=c>0?h.red(`+${c}%`):c<=0?h.green(`${c}%`):"",p=f?`${h.yellow.bold("skipped")} ${h.dim(`original: ${a.toFixed(2)}kb <= optimized: ${g.toFixed(2)}kb`)}`:h.dim(`${a.toFixed(2)}kb -> ${g.toFixed(2)}kb`);e.logger.info(h.dim(P(e.build.outDir))+"/"+h.blueBright(o)+" ".repeat(2+t-o.length)+h.gray(`${u} ${" ".repeat(r-`${c}`.length)}`)+" "+p)}),e.logger.info(`
`)}exports.ViteImageOptimizer=ee;
=======
import fs from "fs";
import fsp from "fs/promises";
import { basename, join, dirname, extname, sep, resolve } from "pathe";
import ansi from "ansi-colors";
const SLASH_RE = /[/\\]/;
function filename(path) {
  const base = path.split(SLASH_RE).pop();
  if (!base) {
    return void 0;
  }
  const separatorIndex = base.lastIndexOf(".");
  if (separatorIndex <= 0) {
    return base;
  }
  return base.slice(0, separatorIndex);
}
function isRegex(src) {
  return Object.prototype.toString.call(src) === "[object RegExp]";
}
function isString(src) {
  return Object.prototype.toString.call(src) === "[object String]";
}
function isArray(src) {
  return Array.isArray(src);
}
function merge(src, target) {
  const deepClone = (src2) => {
    if (typeof src2 !== "object" || isRegex(src2) || src2 === null) return src2;
    const target2 = Array.isArray(src2) ? [] : {};
    for (const key in src2) {
      const value = src2[key];
      target2[key] = deepClone(value);
    }
    return target2;
  };
  const clone = deepClone(src);
  for (const key in target) {
    if (clone[key] === void 0) {
      clone[key] = target[key];
    }
  }
  return clone;
}
function readAllFiles(root) {
  let resultArr = [];
  try {
    if (fs.existsSync(root)) {
      const stat = fs.lstatSync(root);
      if (stat.isDirectory()) {
        const files = fs.readdirSync(root);
        files.forEach(function(file) {
          const t = readAllFiles(join(root, "/", file));
          resultArr = resultArr.concat(t);
        });
      } else {
        resultArr.push(root);
      }
    }
  } catch (error) {
    console.log(error);
  }
  return resultArr;
}
function areFilesMatching(fileName, matcher) {
  if (isString(matcher)) return fileName === matcher;
  if (isRegex(matcher)) return matcher.test(fileName);
  if (isArray(matcher)) return matcher.includes(fileName);
  return false;
}
function decideStyle(text, enableColors) {
  return enableColors ? text : ansi.unstyle(text);
}
function getLogger(rootConfig) {
  return (rootConfig == null ? void 0 : rootConfig.logger) ?? console;
}
function getOutDir(rootConfig) {
  var _a;
  return ((_a = rootConfig == null ? void 0 : rootConfig.build) == null ? void 0 : _a.outDir) ?? "dist";
}
function logErrors(rootConfig, errorsMap, ansiColors) {
  const logger = getLogger(rootConfig);
  const outDir = getOutDir(rootConfig);
  logger.info(decideStyle(`
🚨 ${ansi.red("[vite-plugin-image-optimizer]")} - errors during optimization: `, ansiColors));
  const keyLengths = Array.from(errorsMap.keys(), (name) => name.length);
  const maxKeyLength = Math.max(...keyLengths);
  errorsMap.forEach((message, name) => {
    logger.error(
      decideStyle(
        `${ansi.dim(basename(outDir))}/${ansi.blueBright(name)}${" ".repeat(2 + maxKeyLength - name.length)} ${ansi.red(message)}`,
        ansiColors
      )
    );
  });
  logger.info("\n");
}
function logOptimizationStats(rootConfig, sizesMap, ansiColors) {
  const logger = getLogger(rootConfig);
  const outDir = getOutDir(rootConfig);
  logger.info(decideStyle(`
✨ ${ansi.cyan("[vite-plugin-image-optimizer]")} - optimized images successfully: `, ansiColors));
  const keyLengths = Array.from(sizesMap.keys(), (name) => name.length);
  const valueLengths = Array.from(sizesMap.values(), (value) => `${Math.floor(100 * value.ratio)}`.length);
  const maxKeyLength = Math.max(...keyLengths);
  const valueKeyLength = Math.max(...valueLengths);
  let totalOriginalSize = 0;
  let totalSavedSize = 0;
  sizesMap.forEach((value, name) => {
    const { size, oldSize, ratio, skipWrite, isCached } = value;
    let percentChange;
    if (ratio > 0) {
      percentChange = ansi.red(`+${ratio}%`);
    } else if (ratio <= 0) {
      percentChange = ansi.green(`${ratio}%`);
    } else {
      percentChange = "";
    }
    let sizeText;
    if (skipWrite) {
      sizeText = `${ansi.yellow.bold("skipped")} ${ansi.dim(`original: ${oldSize.toFixed(2)} kB <= optimized: ${size.toFixed(2)} kB`)}`;
    } else if (isCached) {
      sizeText = `${ansi.yellow.bold("cached")} ${ansi.dim(`original: ${oldSize.toFixed(2)} kB; cached: ${size.toFixed(2)} kB`)}`;
    } else {
      sizeText = ansi.dim(`${oldSize.toFixed(2)} kB ⭢  ${size.toFixed(2)} kB`);
    }
    logger.info(
      decideStyle(
        ansi.dim(basename(outDir)) + "/" + ansi.blueBright(name) + " ".repeat(2 + maxKeyLength - name.length) + ansi.gray(`${percentChange} ${" ".repeat(valueKeyLength - `${ratio}`.length)}`) + " " + sizeText,
        ansiColors
      )
    );
    if (!skipWrite) {
      totalOriginalSize += oldSize;
      totalSavedSize += oldSize - size;
    }
  });
  if (totalSavedSize > 0) {
    const savedText = `${totalSavedSize.toFixed(2)}kB`;
    const originalText = `${totalOriginalSize.toFixed(2)}kB`;
    const savingsPercent = `${Math.round(totalSavedSize / totalOriginalSize * 100)}%`;
    logger.info(
      decideStyle(`
💰 total savings = ${ansi.green(savedText)}/${ansi.green(originalText)} ≈ ${ansi.green(savingsPercent)}`, ansiColors)
    );
  }
  logger.info("\n");
}
const VITE_PLUGIN_NAME = "vite-plugin-image-optimizer";
const SVGO_CONFIG = {
  multipass: true,
  plugins: [
    {
      name: "preset-default",
      params: {
        overrides: {
          cleanupNumericValues: false,
          cleanupIds: {
            minify: false,
            remove: false
          },
          convertPathData: false
        }
      }
    },
    "sortAttrs",
    {
      name: "addAttributesToSVGElement",
      params: {
        attributes: [{ xmlns: "http://www.w3.org/2000/svg" }]
      }
    }
  ]
};
const DEFAULT_OPTIONS = {
  logStats: true,
  ansiColors: true,
  includePublic: true,
  exclude: void 0,
  include: void 0,
  test: /\.(jpe?g|png|gif|tiff|webp|svg|avif)$/i,
  svg: SVGO_CONFIG,
  png: {
    // https://sharp.pixelplumbing.com/api-output#png
    quality: 100
  },
  jpeg: {
    // https://sharp.pixelplumbing.com/api-output#jpeg
    quality: 100
  },
  jpg: {
    // https://sharp.pixelplumbing.com/api-output#jpeg
    quality: 100
  },
  tiff: {
    // https://sharp.pixelplumbing.com/api-output#tiff
    quality: 100
  },
  // gif does not support lossless compression
  // https://sharp.pixelplumbing.com/api-output#gif
  gif: {},
  webp: {
    // https://sharp.pixelplumbing.com/api-output#webp
    lossless: true
  },
  avif: {
    // https://sharp.pixelplumbing.com/api-output#avif
    lossless: true
  },
  cache: false,
  cacheLocation: void 0
};
function ViteImageOptimizer(optionsParam = {}) {
  const options = merge(optionsParam, DEFAULT_OPTIONS);
  let outputPath;
  let publicDir;
  let rootConfig;
  const sizesMap = /* @__PURE__ */ new Map();
  const mtimeCache = /* @__PURE__ */ new Map();
  const errorsMap = /* @__PURE__ */ new Map();
  const applySVGO = async (filePath, buffer) => {
    const optimize = (await import("svgo")).optimize;
    return Buffer.from(
      optimize(buffer.toString(), {
        path: filePath,
        ...options.svg
      }).data
    );
  };
  const applySharp = async (filePath, buffer) => {
    const sharp = (await import("sharp")).default;
    const extName = extname(filePath).replace(".", "").toLowerCase();
    return await sharp(buffer, { animated: extName === "gif" }).toFormat(
      extName,
      options[extName]
    ).toBuffer();
  };
  const processFile = async (filePath, buffer) => {
    try {
      let newBuffer;
      let isCached;
      const cachedFilePath = join(options.cacheLocation ?? "", filePath);
      if (options.cache === true && fs.existsSync(cachedFilePath)) {
        newBuffer = await fsp.readFile(cachedFilePath);
        isCached = true;
      } else {
        const engine = /\.svg$/.test(filePath) ? applySVGO : applySharp;
        newBuffer = await engine(filePath, buffer);
        isCached = false;
      }
      if (options.cache === true && !isCached) {
        if (!fs.existsSync(dirname(cachedFilePath))) {
          await fsp.mkdir(dirname(cachedFilePath), { recursive: true });
        }
        await fsp.writeFile(cachedFilePath, newBuffer);
      }
      const newSize = newBuffer.byteLength;
      const oldSize = buffer.byteLength;
      const skipWrite = newSize >= oldSize;
      sizesMap.set(filePath, {
        size: newSize / 1024,
        oldSize: oldSize / 1024,
        ratio: Math.floor(100 * (newSize / oldSize - 1)),
        skipWrite,
        isCached
      });
      return { content: newBuffer, skipWrite };
    } catch (error) {
      errorsMap.set(filePath, error.message);
      return {};
    }
  };
  const getFilesToProcess = (allFiles, getFileName) => {
    if (options.include) {
      return allFiles.reduce((acc, filePath) => {
        const fileName = getFileName(filePath);
        if (areFilesMatching(fileName, options.include)) {
          acc.push(filePath);
        }
        return acc;
      }, []);
    }
    return allFiles.reduce((acc, filePath) => {
      var _a;
      if ((_a = options.test) == null ? void 0 : _a.test(filePath)) {
        const fileName = getFileName(filePath);
        if (!areFilesMatching(fileName, options.exclude)) {
          acc.push(filePath);
        }
      }
      return acc;
    }, []);
  };
  const ensureCacheDirectoryExists = async function() {
    if (options.cache === true && options.cacheLocation && !fs.existsSync(options.cacheLocation)) {
      await fsp.mkdir(options.cacheLocation, { recursive: true });
    }
  };
  return {
    name: VITE_PLUGIN_NAME,
    enforce: "post",
    apply: "build",
    configResolved(c) {
      rootConfig = c;
      outputPath = c.build.outDir;
      if (typeof c.publicDir === "string") {
        publicDir = c.publicDir.replace(/\\/g, "/");
      }
    },
    generateBundle: async (_, bundler) => {
      const allFiles = Object.keys(bundler);
      const files = getFilesToProcess(allFiles, (path) => bundler[path].name);
      if (files.length > 0) {
        await ensureCacheDirectoryExists();
        const handles = files.map(async (filePath) => {
          const source = bundler[filePath].source;
          const { content, skipWrite } = await processFile(filePath, source);
          if (content && content.length > 0 && !skipWrite) {
            bundler[filePath].source = content;
          }
        });
        await Promise.all(handles);
      }
    },
    async closeBundle() {
      if (publicDir && options.includePublic) {
        const allFiles = readAllFiles(publicDir);
        const files = getFilesToProcess(allFiles, (path) => filename(path) + extname(path));
        if (files.length > 0) {
          await ensureCacheDirectoryExists();
          const handles = files.map(async (publicFilePath) => {
            const filePath = publicFilePath.replace(publicDir + sep, "");
            const fullFilePath = resolve(rootConfig.root, outputPath, filePath);
            if (fs.existsSync(fullFilePath) === false) return;
            const { mtimeMs } = await fsp.stat(fullFilePath);
            if (mtimeMs <= (mtimeCache.get(filePath) || 0)) return;
            const buffer = await fsp.readFile(fullFilePath);
            const { content, skipWrite } = await processFile(filePath, buffer);
            if (content && (content == null ? void 0 : content.length) > 0 && !skipWrite) {
              await fsp.writeFile(fullFilePath, content);
              mtimeCache.set(filePath, Date.now());
            }
          });
          await Promise.all(handles);
        }
      }
      if (sizesMap.size > 0 && options.logStats) {
        logOptimizationStats(rootConfig, sizesMap, options.ansiColors ?? true);
      }
      if (errorsMap.size > 0) {
        logErrors(rootConfig, errorsMap, options.ansiColors ?? true);
      }
    }
  };
}
export {
  ViteImageOptimizer
};
>>>>>>> 68944d1d7ae17e1464ed01f5320bfc84233b1024
